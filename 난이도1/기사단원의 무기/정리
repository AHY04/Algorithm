for(int j = 1; j <= i; j++) {
                if(i % j == 0) {
                    count++;
                }
            }
처음에 코드를 작성했을 때, 약수의 개수를 구하는 과정을 이런 식으로 표현했더니 일부 테스트에서 시간초과가 발생하였다.
따라서 이를 해결하기 위해 약수 알고리즘을 제곱근을 활용하여 더 빠르게 수정하였다.
for(int j = 1; j <= Math.sqrt(i); j++) {
                if(i % j == 0) {
                    count++;
                    if(i/j != j) count++;
                }
            }
이 알고리즘의 과정은 이와 같다. 입력값을 100으로 가정한 설명이다.
-for 문 조건을 sqrt 메소드를 사용한 변수로 정의한다.
-원래라면 1 ~ 100까지 돌아야할 for문이 1 ~ 10 까지만 돌아도 약수 추출이 가능해졌다.
-입력 값 100의 약수는 1, 2, 4, 5, 10, 20, 25, 50, 100 이렇게 9개이다.
-10 번의 for 문을 돌며 9개의 약수 중 1을 구한다 (약수 중 작은 수)
-1이 100의 약수라는 것을 알게 된 순간 100이라는 약수도 구할 수 있게 된다.
-그 부분이 if(i / j != j) 부분이다. 100 / 1 != 1  이라면  arr 리스트에 100 / 1 의 값을 넣어준다(약수 중 큰수)
-이 과정을 반복한다.
-10 번의 for 문을 돌며 9개의 약수 중 2을 구한다 (약수 중 작은 수)
-2이 100의 약수라는 것을 알게 된 순간 50이라는 약수도 구할 수 있게 된다.
-그 부분이 if(i / j != j) 부분이다. 100 / 2 != 2  이면  arr 리스트에 100 / 2 의 값을 넣어준다(약수 중 큰수)
-해당 부분은 약수 10을 주의 깊게 봐야한다 10 * 10이 100 이므로 10은 한번만 arr 리스트에 한번만 넣어야한다.
-그 부분이 if(i / j != j) 부분이다. 100 / 10 != 10 false 이기 때문에 배열에 한번만 들어간다.
